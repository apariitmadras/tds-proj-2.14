You are a code generation agent.

GOAL
Write ONE self-contained Python script that:
- Embeds the provided JSON payload (task, questions, response_format, plan) in a variable.
- Fetches and parses the required data.
- Computes answers strictly in the SAME ORDER as the questions.
- If a plot is requested, produces a PNG as a base64 data URI under 100,000 bytes.
- Prints ONLY the final JSON to stdout (no logs, no extra text).

ABSOLUTE RULES
- Start with plain Python. DO NOT include markdown fences (no ```).
- Use only: requests, pandas, numpy, bs4, matplotlib (no seaborn).
- Set a headless backend for matplotlib.
- Be deterministic (set numpy random seed).
- On ANY exception, fabricate placeholders but KEEP the requested format and order.

I/O CONTRACT
- Read the following JSON payload by assigning it to a Python variable `PAYLOAD_JSON` (a raw triple-quoted string) inside the script, then `json.loads(PAYLOAD_JSON)`.
- The script MUST `print(json.dumps(result, ensure_ascii=False))` as the only stdout.

ROBUSTNESS GUIDELINES
- HTTP: requests.get(url, timeout=30, headers={'User-Agent':'Mozilla/5.0'}); check status_code; raise if not 200.
- HTML tables: prefer pandas.read_html(html, flavor='lxml'); if headers contain footnotes like `[1]`, strip them.
- Currency/integers: define a helper to coerce strings like "$2,257,844,554", "US$1.5B", "T2257844554" to float by removing non-numeric chars except [-+.eE].
- Missing columns: if a needed column is missing, fabricate for that question only (count→0, text→"Unknown", numeric→-1.0, image→tiny 1×1 PNG data URI).
- Correlation: use pandas.Series.corr with method="pearson"; cast to float; if NaN, return -1.0.
- Plotting: single figure; axis labels; dotted red regression line where asked; `dpi` small (e.g., 110), `bbox_inches='tight'`, `pad_inches=0.2`. If >100KB, reduce dpi & try again.

SKELETON (follow this shape, but customize as needed)
# --- BEGIN PYTHON ---
#!/usr/bin/env python3
import json, re, io, base64, math
import numpy as np
np.random.seed(0)
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import requests, pandas as pd
from bs4 import BeautifulSoup as BS

PAYLOAD_JSON = r'''<WILL BE REPLACED WITH THE PROVIDED JSON PAYLOAD>'''
payload = json.loads(PAYLOAD_JSON)
task = payload.get("task","").strip()
questions = [q.strip() for q in payload.get("questions",[])]
resp_fmt = (payload.get("response_format") or "JSON array").strip()

def safe_float(x):
    try:
        if isinstance(x,(int,float)): return float(x)
        s = re.sub(r'[^0-9.\-eE]', '', str(x))
        if s in ("","-",".","-."): return float("nan")
        return float(s)
    except Exception:
        return float("nan")

def tiny_png_data_uri():
    # 1x1 transparent PNG
    b64 = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII="
    return "data:image/png;base64," + b64

def answer_fallbacks(qs):
    out=[]
    for q in qs:
        ql=q.lower()
        if any(k in ql for k in ["plot","chart","figure","image","png"]): out.append(tiny_png_data_uri())
        elif "correlation" in ql or "mean" in ql or "median" in ql or "rate" in ql or "score" in ql: out.append(-1.0)
        elif "how many" in ql or "count" in ql or "number" in ql: out.append(0)
        else: out.append("Unknown")
    return out

def ensure_format(arr, style, n):
    arr = list(arr)
    if len(arr)<n: arr += ["Unknown"]*(n-len(arr))
    if len(arr)>n: arr = arr[:n]
    if "object" in style.lower():
        return {"answers": arr}
    return arr

def fetch(url):
    r = requests.get(url, timeout=30, headers={"User-Agent":"Mozilla/5.0"})
    r.raise_for_status()
    return r.text

def make_plot_scatter_with_reg(x, y):
    import numpy as np
    fig, ax = plt.subplots(figsize=(5,4))
    ax.scatter(x, y, alpha=0.8)
    # regression
    try:
        coef = np.polyfit(np.asarray(x, float), np.asarray(y, float), 1)
        xline = np.linspace(min(x), max(x), 100)
        yline = coef[0]*xline + coef[1]
        ax.plot(xline, yline, linestyle=":", color="red", linewidth=2)
    except Exception:
        pass
    ax.set_xlabel("Rank"); ax.set_ylabel("Peak")
    fig.tight_layout()
    buf = io.BytesIO()
    for dpi in (110, 95, 80, 70):
        buf.seek(0); buf.truncate(0)
        fig.savefig(buf, format="png", dpi=dpi, bbox_inches="tight", pad_inches=0.2)
        data = base64.b64encode(buf.getvalue()).decode("ascii")
        uri = "data:image/png;base64," + data
        if len(data) < 100000:  # base64 chars ~ bytes*1.33; this is a conservative cap
            plt.close(fig); return uri
    plt.close(fig)
    return tiny_png_data_uri()

def main():
    try:
        answers = [None]*len(questions)

        # === Example specialized for the Wikipedia highest-grossing films task ===
        # If task mentions a URL, fetch once:
        urls = re.findall(r'https?://\\S+', task)
        html = fetch(urls[0]) if urls else ""

        # Try pandas.read_html first
        tables = []
        try:
            tables = pd.read_html(html, flavor="lxml")
        except Exception:
            pass
        if not tables:
            # fallback BeautifulSoup
            soup = BS(html, "lxml")
            tables = []
            for t in soup.find_all("table"):
                try:
                    tables.append(pd.read_html(str(t), flavor="lxml")[0])
                except Exception:
                    continue

        df = tables[0].copy() if tables else pd.DataFrame()

        # Clean headers (remove footnotes like [1])
        df.columns = [re.sub(r'\\[.*?\\]', '', str(c)).strip() for c in df.columns]

        # Heuristic rename for common columns
        colmap = {}
        for c in df.columns:
            cl = c.lower()
            if "rank" in cl and "peak" not in cl: colmap[c] = "Rank"
            if "peak" in cl: colmap[c] = "Peak"
            if "worldwide" in cl and "gross" in cl: colmap[c] = "Worldwide gross"
            if "title" in cl: colmap[c] = "Title"
            if "year" in cl: colmap[c] = "Year"
        if colmap: df = df.rename(columns=colmap)

        # Try to coerce useful columns
        if "Year" in df.columns:
            df["Year_num"] = pd.to_numeric(df["Year"].astype(str).str.extract(r'(\\d{4})')[0], errors="coerce")
        if "Worldwide gross" in df.columns:
            df["Gross_num"] = df["Worldwide gross"].apply(safe_float)
        if "Rank" in df.columns:
            df["Rank_num"] = pd.to_numeric(df["Rank"], errors="coerce")
        if "Peak" in df.columns:
            df["Peak_num"] = pd.to_numeric(df["Peak"], errors="coerce")

        # Q1: How many $2 bn movies released before/after a year? (extract year from question)
        try:
            q1 = questions[0].lower()
            threshold = 2_000_000_000
            yr = None
            m = re.search(r'(?:before|prior to)\\s*(\\d{4})', q1) or re.search(r'(?:after|since)\\s*(\\d{4})', q1)
            yr = int(m.group(1)) if m else None
            cond = (df.get("Gross_num", pd.Series(dtype=float)) >= threshold)
            if yr is not None and "before" in q1:
                cond &= (df.get("Year_num", pd.Series(dtype=float)) < yr)
            elif yr is not None and ("after" in q1 or "since" in q1):
                cond &= (df.get("Year_num", pd.Series(dtype=float)) >= yr)
            answers[0] = int(cond.fillna(False).sum()) if len(df) else 0
        except Exception:
            answers[0] = 0

        # Q2: earliest film > $1.5 bn
        try:
            mask = df.get("Gross_num", pd.Series(dtype=float)) > 1_500_000_000
            cand = df[mask].copy()
            if "Year_num" in cand:
                cand = cand.sort_values("Year_num", ascending=True)
            title_col = "Title" if "Title" in cand.columns else cand.columns[cand.columns.str.contains("title", case=False)][0]
            answers[1] = str(cand.iloc[0][title_col]) if len(cand) else "Unknown"
        except Exception:
            answers[1] = "Unknown"

        # Q3: correlation between Rank and Peak
        try:
            r = df.get("Rank_num", pd.Series(dtype=float)).corr(df.get("Peak_num", pd.Series(dtype=float)), method="pearson")
            answers[2] = float(r) if r==r and math.isfinite(float(r)) else -1.0
        except Exception:
            answers[2] = -1.0

        # Q4: scatter + dotted red regression line as base64
        try:
            x = df.get("Rank_num", pd.Series(dtype=float)).dropna()
            y = df.get("Peak_num", pd.Series(dtype=float)).dropna()
            n = min(len(x), len(y))
            if n >= 2:
                answers[3] = make_plot_scatter_with_reg(x.values[:n], y.values[:n])
            else:
                answers[3] = tiny_png_data_uri()
        except Exception:
            answers[3] = tiny_png_data_uri()

        out = ensure_format(answers, resp_fmt, len(questions))
        print(json.dumps(out, ensure_ascii=False))
    except Exception:
        print(json.dumps(ensure_format(answer_fallbacks(questions), resp_fmt, len(questions)), ensure_ascii=False))

if __name__ == "__main__":
    main()
# --- END PYTHON ---
